---
interface Props {
  sandboxId: string;
  host: string;
}

const { sandboxId, host } = Astro.props;
---

<!--
  Client-side sandbox initialization and progress tracking.

  ## Progress strategy: WebSocket primary, polling as deferred fallback

  Sandbox initialization runs server-side inside `waitUntil()` and takes
  30-40s. The client needs to know when it's done. Two channels exist:

  1. **WebSocket (primary)** — Connects to `/api/ws?sandboxId=...` for
     real-time progress broadcasts from the server. This is the preferred
     channel and delivers step-by-step updates (creating workspace,
     writing files, starting server, etc.).

  2. **Polling (deferred fallback)** — Calls `actions.startSandbox()`
     periodically to check the server-side state. Only activates if
     WebSocket has not delivered ANY message after 10 seconds.

  Why polling exists at all: WebSocket broadcasts from `waitUntil()`
  don't reliably reach clients in workerd. The init runs in a detached
  promise (kept alive by `waitUntil`), and the WS connections are
  registered in a different request context. In practice, WS messages
  sometimes never arrive. Polling covers this gap.

  Why polling is deferred (not immediate): The original implementation
  polled every 3s starting immediately alongside WebSocket. This caused
  duplicate paired POST requests — the initial action call takes ~3s,
  and the first poll tick fires nearly simultaneously. With 5 concurrent
  containers allowed (max_instances: 5), this traffic was wasteful and
  made debugging harder. See decision 19 in _plan/4. decisions.md.

  Flow:
    init() → action call → connect WS → schedule fallback (5s)
      ├─ WS delivers progress/ready/error → wsHasDelivered=true → polling skipped
      └─ WS silent after 5s → poll every 5s → self-cancels if WS wakes
-->

<div
  class="sandbox-container"
  x-data="sandbox"
  data-sandbox-id={sandboxId}
  data-host={host}
>
  <div class="loading-state" x-show="state === 'loading'">
    <div class="spinner"></div>
    <div class="status-text" x-text="statusText"></div>
    <div class="step-indicator" x-text="stepKey"></div>
  </div>

  <div class="ready-state" x-show="state === 'ready'" x-cloak>
    <div class="preview-url" x-text="previewUrl"></div>
    <iframe title="Sandbox Preview" loading="lazy" :src="previewUrl"></iframe>
  </div>

  <div class="error-state" x-show="state === 'error'" x-cloak>
    <div class="error-message" x-text="errorMessage"></div>
    <button class="retry-btn" @click="location.reload()">Retry</button>
  </div>
</div>

<script>
  /**
   * Astro's bundled <script> — only place where `astro:actions` imports work.
   * Sets up Alpine.js data component and wires up the async init logic.
   */
  import Alpine from "alpinejs";
  import { actions } from "astro:actions";

  const STEP_DESCRIPTIONS: Record<string, string> = {
    creating_workspace: "Creating workspace...",
    writing_files: "Setting up Express server...",
    starting_server: "Starting Express server...",
    waiting_for_ready: "Waiting for server to be ready...",
    exposing_port: "Configuring preview URL...",
  };

  /** Grace period before polling activates (gives WS time to deliver). */
  const POLL_FALLBACK_DELAY = 5_000;
  /** Polling interval — intentionally slow since this is a backup. */
  const POLL_INTERVAL = 5_000;

  // Read data attributes from the container element before Alpine.data
  // runs, avoiding reliance on Alpine's `$el` magic property (which the
  // Astro TS checker can't resolve).
  const containerEl = document.querySelector<HTMLElement>(".sandbox-container");
  const pageSandboxId = containerEl?.dataset.sandboxId ?? "";
  const pageHost = containerEl?.dataset.host ?? window.location.host;

  Alpine.data("sandbox", () => ({
    // --- Reactive UI state ---
    state: "loading" as "loading" | "ready" | "error",
    statusText: "Initializing...",
    stepKey: "",
    previewUrl: "",
    errorMessage: "",

    // --- Internal (non-reactive) bookkeeping ---
    _pollTimer: null as ReturnType<typeof setInterval> | null,
    _pollFallbackTimer: null as ReturnType<typeof setTimeout> | null,
    _ws: null as WebSocket | null,
    _settled: false,
    _wsHasDelivered: false,

    init() {
      this._start();
    },

    async _start() {
      const sandboxId = pageSandboxId;
      const host = pageHost;

      try {
        this.statusText = "Starting sandbox...";

        const result = await actions.startSandbox({ sandboxId, host });

        if (result.error) {
          this._showError(result.error.message ?? "Failed to start sandbox");
          return;
        }

        const { data } = result;

        // Already ready (e.g. page refresh while container still alive)
        if (data.status === "ready" && data.previewUrl) {
          this._showReady(data.previewUrl);
          return;
        }

        // Connect WebSocket — primary channel for progress updates
        const wsEndpoint = data.wsEndpoint || `/api/ws?sandboxId=${sandboxId}`;
        this._connectWebSocket(wsEndpoint, sandboxId, host);

        // Schedule deferred polling fallback
        this._schedulePollFallback(sandboxId, host);
      } catch (err) {
        console.error("Failed to start sandbox:", err);
        this._showError("Failed to start sandbox. Please try again.");
      }
    },

    _showReady(url: string) {
      this._stopAll();
      this.state = "ready";
      this.previewUrl = url;
    },

    _showError(message: string) {
      this._stopAll();
      this.state = "error";
      this.errorMessage = message;
    },

    /** Clean up all timers and connections (called on ready or error). */
    _stopAll() {
      this._settled = true;
      if (this._pollFallbackTimer) {
        clearTimeout(this._pollFallbackTimer);
        this._pollFallbackTimer = null;
      }
      if (this._pollTimer) {
        clearInterval(this._pollTimer);
        this._pollTimer = null;
      }
      if (this._ws) {
        this._ws.onclose = null; // prevent auto-reconnect
        this._ws.close();
        this._ws = null;
      }
    },

    /**
     * Schedule the polling fallback with a delay.
     * If WebSocket has delivered any message by the time the timer fires,
     * polling is skipped entirely — WS is working fine.
     */
    _schedulePollFallback(sandboxId: string, host: string) {
      this._pollFallbackTimer = setTimeout(() => {
        if (this._settled || this._wsHasDelivered) return;
        console.warn("WebSocket silent after timeout — starting poll fallback");
        this._startPolling(sandboxId, host);
      }, POLL_FALLBACK_DELAY);
    },

    /**
     * Poll the startSandbox action to check for ready state.
     * Self-cancels if WebSocket comes alive mid-poll.
     */
    _startPolling(sandboxId: string, host: string) {
      if (this._pollTimer) return;
      this._pollTimer = setInterval(async () => {
        if (this._settled || this._wsHasDelivered) {
          if (this._pollTimer) {
            clearInterval(this._pollTimer);
            this._pollTimer = null;
          }
          return;
        }
        try {
          const result = await actions.startSandbox({ sandboxId, host });
          if (result.error) return;
          // The action returns a discriminated union but TS narrows too
          // aggressively after the "ready" check. Use a loose type here
          // since polling just needs status + optional fields.
          const data = result.data as { status: string; previewUrl?: string; message?: string };
          if (data.status === "ready" && data.previewUrl) {
            this._showReady(data.previewUrl);
          } else if (data.status === "error") {
            this._showError(data.message ?? "Sandbox initialization failed");
          }
        } catch {
          // Swallow poll errors — this is a fallback, not critical path
        }
      }, POLL_INTERVAL);
    },

    /** Connect WebSocket for real-time progress from server-side init. */
    _connectWebSocket(endpoint: string, sandboxId: string, host: string) {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      this._ws = new WebSocket(
        `${protocol}//${window.location.host}${endpoint}`,
      );

      this._ws.onmessage = (event: MessageEvent) => {
        const data = JSON.parse(event.data);
        // Only count substantive messages (progress/ready/error) as
        // "delivered". The WS route may send a "connected" handshake ack
        // which doesn't carry init state.
        if (data.type === "progress" || data.type === "ready" || data.type === "error") {
          this._wsHasDelivered = true;
        }
        this._handleMessage(data);
      };

      this._ws.onerror = () => {
        console.warn("WebSocket error, relying on polling fallback");
      };

      this._ws.onclose = () => {
        if (this._settled) return;
        // Auto-reconnect — WS may close during container startup.
        setTimeout(() => this._connectWebSocket(endpoint, sandboxId, host), 3000);
      };
    },

    _handleMessage(data: Record<string, string>) {
      switch (data.type) {
        case "progress":
          this.statusText = STEP_DESCRIPTIONS[data.step] ?? "Initializing...";
          this.stepKey = data.step;
          break;
        case "ready":
          this._showReady(data.previewUrl);
          break;
        case "error":
          this._showError(data.message);
          break;
      }
    },
  }));

  Alpine.start();
</script>

<style>
  [x-cloak] {
    display: none !important;
  }

  .sandbox-container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .loading-state {
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 40px;
    text-align: center;
    height: 400px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #e3f2fd;
    border-top: 4px solid #2196f3;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  .step-indicator {
    color: #666;
    font-size: 14px;
    margin-top: 10px;
    font-family: monospace;
  }

  .preview-url {
    background: #e3f2fd;
    padding: 10px;
    border-radius: 4px;
    margin-bottom: 20px;
    font-family: monospace;
    word-break: break-all;
  }

  iframe {
    width: 100%;
    height: 600px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
  }

  .error-state {
    text-align: center;
    padding: 40px;
  }

  .error-message {
    color: #d32f2f;
    margin-bottom: 20px;
  }

  button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    background: #2196f3;
    color: white;
    border: none;
    border-radius: 4px;
  }

  button:hover {
    background: #1976d2;
  }
</style>
