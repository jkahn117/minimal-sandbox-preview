---
interface Props {
  sandboxId: string;
  host: string;
}

const { sandboxId, host } = Astro.props;
---

<!--
  Client-side sandbox initialization and progress tracking.

  ## Progress strategy: WebSocket primary, polling as deferred fallback

  Sandbox initialization runs server-side inside `waitUntil()` and takes
  30-40s. The client needs to know when it's done. Two channels exist:

  1. **WebSocket (primary)** — Connects to `/api/ws?sandboxId=...` for
     real-time progress broadcasts from the server. This is the preferred
     channel and delivers step-by-step updates (creating workspace,
     writing files, starting server, etc.).

  2. **Polling (deferred fallback)** — Calls `actions.startSandbox()`
     periodically to check the server-side state. Only activates if
     WebSocket has not delivered ANY message after 10 seconds.

  Why polling exists at all: WebSocket broadcasts from `waitUntil()`
  don't reliably reach clients in workerd. The init runs in a detached
  promise (kept alive by `waitUntil`), and the WS connections are
  registered in a different request context. In practice, WS messages
  sometimes never arrive. Polling covers this gap.

  Why polling is deferred (not immediate): The original implementation
  polled every 3s starting immediately alongside WebSocket. This caused
  duplicate paired POST requests — the initial action call takes ~3s,
  and the first poll tick fires nearly simultaneously. With 5 concurrent
  containers allowed (max_instances: 5), this traffic was wasteful and
  made debugging harder. See decision 19 in _plan/4. decisions.md.

  Flow:
    init() → action call → connect WS → schedule fallback (5s)
      ├─ WS delivers progress/ready/error → wsHasDelivered=true → polling skipped
      └─ WS silent after 5s → poll every 5s → self-cancels if WS wakes
-->

<div
  class="sandbox-container"
  x-data="sandbox"
  data-sandbox-id={sandboxId}
  data-host={host}
>
  <div class="loading-state" x-show="state === 'loading'">
    <div class="spinner"></div>
    <div class="status-text" x-text="statusText"></div>
    <div class="step-indicator" x-text="stepKey"></div>
  </div>

  <div class="ready-state" x-show="state === 'ready'" x-cloak>
    <div class="preview-url" x-text="previewUrl"></div>
    <iframe title="Sandbox Preview" loading="lazy" :src="previewUrl"></iframe>
  </div>

  <div class="error-state" x-show="state === 'error'" x-cloak>
    <div class="error-message" x-text="errorMessage"></div>
    <button class="retry-btn" @click="location.reload()">Retry</button>
  </div>
</div>

<script>
  /**
   * Thin Alpine.js binding layer. All WS/polling logic lives in
   * SandboxPreview (src/lib/sandbox-preview.ts). This script just
   * wires the library's events to Alpine's reactive state.
   */
  import Alpine from "alpinejs";
  import { actions } from "astro:actions";
  import { SandboxPreview, type ActionResult } from "../lib/sandbox-preview";

  const STEP_DESCRIPTIONS: Record<string, string> = {
    creating_workspace: "Creating workspace...",
    writing_files: "Setting up vinext server...",
    starting_server: "Starting vinext server...",
    waiting_for_ready: "Waiting for server to be ready...",
    exposing_port: "Configuring preview URL...",
  };

  const containerEl = document.querySelector<HTMLElement>(".sandbox-container");
  const sandboxId = containerEl?.dataset.sandboxId ?? "";
  const host = containerEl?.dataset.host ?? window.location.host;

  /** Adapt Astro Actions' result shape to what SandboxPreview expects. */
  const callAction = async (): Promise<ActionResult> => {
    const result = await actions.startSandbox({ sandboxId, host });
    if (result.error) {
      return { error: { message: result.error.message } };
    }
    // Widen the discriminated union — the library only needs status +
    // optional previewUrl/wsEndpoint/message fields.
    const data = result.data as ActionResult["data"];
    return { data };
  };

  Alpine.data("sandbox", () => ({
    state: "loading" as "loading" | "ready" | "error",
    statusText: "Initializing...",
    stepKey: "",
    previewUrl: "",
    errorMessage: "",

    _preview: null as SandboxPreview | null,

    init() {
      const preview = new SandboxPreview({
        start: callAction,
        poll: callAction,
      });

      preview.on("progress", ({ step }) => {
        this.statusText = STEP_DESCRIPTIONS[step] ?? "Initializing...";
        this.stepKey = step;
      });

      preview.on("ready", ({ previewUrl }) => {
        this.state = "ready";
        this.previewUrl = previewUrl;
      });

      preview.on("error", ({ message }) => {
        this.state = "error";
        this.errorMessage = message;
      });

      this._preview = preview;
      preview.init();
    },

    destroy() {
      this._preview?.destroy();
    },
  }));

  Alpine.start();
</script>

<style>
  [x-cloak] {
    display: none !important;
  }

  .sandbox-container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .loading-state {
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 40px;
    text-align: center;
    height: 400px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #e3f2fd;
    border-top: 4px solid #2196f3;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  .step-indicator {
    color: #666;
    font-size: 14px;
    margin-top: 10px;
    font-family: monospace;
  }

  .preview-url {
    background: #e3f2fd;
    padding: 10px;
    border-radius: 4px;
    margin-bottom: 20px;
    font-family: monospace;
    word-break: break-all;
  }

  iframe {
    width: 100%;
    height: 600px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
  }

  .error-state {
    text-align: center;
    padding: 40px;
  }

  .error-message {
    color: #d32f2f;
    margin-bottom: 20px;
  }

  button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    background: #2196f3;
    color: white;
    border: none;
    border-radius: 4px;
  }

  button:hover {
    background: #1976d2;
  }
</style>
