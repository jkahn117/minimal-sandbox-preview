# Cloudflare Sandbox SDK Minimal Example - Implementation Plan (Revised)

## Project Goal

Build a minimal, functional example of Cloudflare's Sandbox SDK to understand local development vs production differences. The project demonstrates running an Express.js application inside an isolated sandbox container and exposing it via preview URLs.

**Key Requirements:**
- Astro frontend with Cloudflare adapter (unified project structure)
- Cloudflare Worker with Sandbox SDK (embedded in Astro)
- Docker container with Node v22+ and pnpm
- Express.js app with single `GET /` route
- Auto-start Express server and display in iframe
- Explicit local vs production behavior differences

---

## Critical Version Constraint

**⚠️ MANDATORY: SDK and Docker image versions must match exactly**

```
SDK Version:     @cloudflare/sandbox@0.7.4
Docker Image:    docker.io/cloudflare/sandbox:0.7.4
```

Mismatched versions cause compatibility warnings and potential runtime failures.

---

## Architecture Overview

**Revised Approach**: Single unified Astro project with embedded Worker

Instead of separate `worker/` and `astro-frontend/` directories, we use:
- **Astro** as the main framework with `@astrojs/cloudflare` adapter
- **Worker entry point** defined in `src/worker/index.ts`
- **Astro pages** for the frontend UI
- **Hono.js** for routing (if needed beyond basic proxy)

This approach uses the Cloudflare adapter to bundle the Worker with Astro.

---

## Project Structure

```
sandbox-minimal-example/
├── package.json                    # Project dependencies
├── plan.md                         # This document
├── research.md                     # SDK documentation reference
├── tsconfig.json                   # TypeScript configuration
├── wrangler.jsonc                  # Wrangler configuration (minimal)
├── sandbox/                        # Container configuration
│   ├── Dockerfile                  # Node 22 + pnpm + Express setup
│   └── express-app/                # App to run inside sandbox
│       ├── package.json            # Express dependencies
│       ├── pnpm-lock.yaml          # Lockfile
│       └── server.js               # Express server code
└── src/
    ├── worker/
    │   └── index.ts                # Worker entry point (auto-starts sandbox)
    └── pages/
        └── index.astro             # Main page with iframe
```

---

## Phase 1: Project Configuration

### 1.1 Package Configuration

**File:** `package.json`

**Purpose:** Define Astro project with Cloudflare adapter and Sandbox SDK.

**Key Components:**
- `@astrojs/cloudflare` - Cloudflare adapter for Astro
- `astro` - Main framework
- `@cloudflare/sandbox@0.7.4` - Sandbox SDK
- `hono` - Lightweight routing (minimal usage)
- `wrangler` - CLI for type generation and deployment

**Configuration:**

```json
{
  "name": "sandbox-minimal-example",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "astro dev",
    "build": "astro build",
    "preview": "astro preview",
    "types": "wrangler types",
    "deploy": "astro build && wrangler deploy"
  },
  "dependencies": {
    "@astrojs/cloudflare": "^12.0.0",
    "@cloudflare/sandbox": "0.7.4",
    "astro": "^5.0.0",
    "hono": "^4.0.0"
  },
  "devDependencies": {
    "typescript": "^5.3.0",
    "wrangler": "^3.0.0"
  }
}
```

### 1.2 TypeScript Configuration

**File:** `tsconfig.json`

**Purpose:** TypeScript compiler settings for the project.

**Key Components:**
- Includes `workers-configuration.d.ts` generated by `wrangler types`
- Strict mode enabled
- ES2022 target

**Configuration:**

```json
{
  "extends": "astro/tsconfigs/strict",
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["./workers-configuration.d.ts"]
  },
  "include": ["src/**/*"]
}
```

**Note:** Run `npm run types` (wrangler types) to generate `workers-configuration.d.ts` after installing dependencies.

### 1.3 Wrangler Configuration

**File:** `wrangler.jsonc`

**Purpose:** Minimal Wrangler config for Sandbox container binding.

**Key Components:**
- Container binding for Sandbox
- Durable Object binding
- Migration for Sandbox class

**Configuration:**

```jsonc
{
  "$schema": "./node_modules/wrangler/config-schema.json",
  "name": "sandbox-minimal-example",
  "main": "./dist/worker/index.js",
  "compatibility_date": "2025-02-18",
  
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./sandbox/Dockerfile",
      "instance_type": "lite",
      "max_instances": 1
    }
  ],
  
  "durable_objects": {
    "bindings": [
      {
        "class_name": "Sandbox",
        "name": "Sandbox"
      }
    ]
  },
  
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["Sandbox"]
    }
  ]
}
```

### 1.4 Astro Configuration

**File:** `astro.config.mjs`

**Purpose:** Configure Astro with Cloudflare adapter.

**Key Components:**
- `@astrojs/cloudflare` adapter
- Output mode: `server` (for Worker functionality)
- Custom Worker entry point

**Configuration:**

```javascript
import { defineConfig } from 'astro/config';
import cloudflare from '@astrojs/cloudflare';

export default defineConfig({
  output: 'server',
  adapter: cloudflare({
    // Use custom Worker entry point
    runtime: {
      mode: 'local'
    }
  }),
  vite: {
    build: {
      rollupOptions: {
        input: {
          worker: './src/worker/index.ts'
        }
      }
    }
  }
});
```

---

## Phase 2: Sandbox Container

### 2.1 Dockerfile

**File:** `sandbox/Dockerfile`

**Purpose:** Container image with Node.js 22 and pnpm.

**Key Components:**
- Base: `docker.io/cloudflare/sandbox:0.7.4`
- Node.js 22.x via NodeSource
- pnpm global install
- `EXPOSE 3001` (REQUIRED for local dev)

**Configuration:**

```dockerfile
FROM docker.io/cloudflare/sandbox:0.7.4

# Install Node.js 22.x
RUN curl -fsSL https://deb.nodesource.com/setup_22.x | bash - && \
    apt-get update && \
    apt-get install -y nodejs && \
    npm install -g pnpm && \
    rm -rf /var/lib/apt/lists/*

# Verify installations
RUN node --version && pnpm --version

# Expose port 3001 for Express app
# NOTE: Port 3000 is reserved by Sandbox internal Bun server
EXPOSE 3001

# Set working directory
WORKDIR /workspace

# Copy and install dependencies during build
COPY express-app/package.json express-app/pnpm-lock.yaml ./
RUN pnpm install

# Copy application code
COPY express-app/server.js ./

# Use sandbox binary as entrypoint
ENTRYPOINT ["/sandbox"]
```

### 2.2 Express Application

**File:** `sandbox/express-app/package.json`

**Configuration:**

```json
{
  "name": "sandbox-express-app",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "express": "^4.18.2"
  }
}
```

**File:** `sandbox/express-app/server.js`

**Purpose:** Simple Express server with single route.

**Configuration:**

```javascript
import express from 'express';

const app = express();
const PORT = process.env.PORT || 3001;

app.get('/', (req, res) => {
  res.json({
    message: 'Hello from Express in Cloudflare Sandbox!',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    port: PORT
  });
});

// Health check for readiness
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Express server running on port ${PORT}`);
});
```

---

## Phase 3: Worker Implementation

### 3.1 Worker Entry Point

**File:** `src/worker/index.ts`

**Purpose:** Auto-start Express server in sandbox on first request and proxy to it.

**Key Changes from Original Plan:**
- No REST API endpoints - just auto-start and proxy
- Single responsibility: Initialize sandbox, start Express, expose port, proxy requests
- Logs preview URL for visibility
- Uses `proxyToSandbox` to route preview URL requests

**Configuration:**

```typescript
import { getSandbox, proxyToSandbox, type Sandbox } from '@cloudflare/sandbox';
import { Hono } from 'hono';

// Re-export Sandbox for Durable Object binding
export { Sandbox } from '@cloudflare/sandbox';

// Environment type
type Env = {
  Sandbox: DurableObjectNamespace<Sandbox>;
};

// Track initialization state
let isInitialized = false;
let previewUrl: string | null = null;

const app = new Hono<{ Bindings: Env }>();

// Middleware to handle preview URL proxying
app.use('*', async (c, next) => {
  // Try to proxy to sandbox first (handles preview URLs)
  const proxyResponse = await proxyToSandbox(c.req.raw, c.env);
  if (proxyResponse) {
    return proxyResponse;
  }
  
  // Not a preview URL, continue to next handler
  await next();
});

// Main handler - auto-initialize sandbox on first request
app.get('/', async (c) => {
  const sandbox = getSandbox(c.env.Sandbox, 'minimal-example-sandbox', {
    normalizeId: true  // CRITICAL: lowercase ID for preview URLs
  });
  
  // Initialize on first request
  if (!isInitialized) {
    try {
      console.log('Initializing sandbox and starting Express server...');
      
      // Setup workspace
      await sandbox.mkdir('/workspace', { recursive: true });
      
      // Write package.json
      await sandbox.writeFile('/workspace/package.json', JSON.stringify({
        name: 'sandbox-express-app',
        version: '1.0.0',
        type: 'module',
        dependencies: { express: '^4.18.2' }
      }, null, 2));
      
      // Write Express server
      await sandbox.writeFile('/workspace/server.js', `
import express from 'express';

const app = express();
const PORT = process.env.PORT || 3001;

app.get('/', (req, res) => {
  res.json({
    message: 'Hello from Express in Cloudflare Sandbox!',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    port: PORT
  });
});

app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.listen(PORT, '0.0.0.0', () => {
  console.log('Express server running on port ' + PORT);
});
      `.trim());
      
      // Install dependencies
      console.log('Installing dependencies...');
      await sandbox.exec('npm install', { cwd: '/workspace' });
      
      // Start Express server
      console.log('Starting Express server...');
      await sandbox.startProcess('node server.js', {
        cwd: '/workspace',
        env: { 
          PORT: '3001',
          NODE_ENV: 'production'
        }
      });
      
      // Wait for startup
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Verify server is ready
      let isReady = false;
      for (let i = 0; i < 5; i++) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        const health = await sandbox.exec(
          'curl -s http://localhost:3001/health || echo "not ready"'
        );
        if (health.stdout.includes('ok')) {
          isReady = true;
          break;
        }
      }
      
      if (!isReady) {
        throw new Error('Server failed to start within timeout');
      }
      
      // Expose port
      const hostname = new URL(c.req.url).hostname;
      const exposed = await sandbox.exposePort(3001, {
        hostname,
        name: 'express-server',
        token: 'express'
      });
      
      previewUrl = exposed.url;
      isInitialized = true;
      
      console.log('✓ Sandbox initialized successfully');
      console.log('Preview URL:', previewUrl);
      
    } catch (error) {
      console.error('Failed to initialize sandbox:', error);
      return c.json({
        error: 'Failed to initialize sandbox',
        message: error instanceof Error ? error.message : 'Unknown error'
      }, 500);
    }
  }
  
  // Return HTML page with iframe
  return c.html(`
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sandbox Preview</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      margin: 0 0 10px 0;
    }
    .info {
      color: #666;
      margin-bottom: 20px;
    }
    .preview-url {
      background: #e3f2fd;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
      font-family: monospace;
      word-break: break-all;
    }
    iframe {
      width: 100%;
      height: 600px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cloudflare Sandbox SDK Minimal Example</h1>
    <div class="info">
      Express.js server running inside Cloudflare Sandbox container
    </div>
    <div class="preview-url">
      Preview URL: ${previewUrl || 'Initializing...'}
    </div>
    ${previewUrl ? `<iframe src="${previewUrl}" title="Sandbox Preview"></iframe>` : '<p>Loading...</p>'}
  </div>
</body>
</html>
  `);
});

// Export Hono app as default
export default app;
```

**Key Design Decisions:**

1. **Auto-initialization**: Sandbox starts automatically on first request to `/`
2. **No API endpoints**: Simple proxy and HTML response only
3. **Hono for routing**: Clean middleware pattern for `proxyToSandbox`
4. **HTML response**: Returns page with iframe pointing to preview URL
5. **State tracking**: `isInitialized` prevents re-initialization
6. **Console logging**: Logs preview URL for visibility in dev tools

---

## Phase 4: Frontend Page

### 4.1 Main Page

**File:** `src/pages/index.astro`

**Purpose:** Simple page that loads the Worker (which returns the iframe HTML).

**Note:** With the revised architecture, the Astro page is minimal because the Worker handles everything. The page either:
- Returns static content if accessed directly (SSR disabled for this route)
- Or the Worker intercepts and returns the HTML with iframe

**Configuration:**

```astro
---
// This page is handled by the Worker
// The Worker returns HTML with an iframe pointing to the sandbox preview
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sandbox SDK Example</title>
</head>
<body>
  <p>Loading sandbox...</p>
  <script>
    // Trigger Worker initialization by fetching root
    window.location.href = '/';
  </script>
</body>
</html>
```

**Alternative Approach**: Since the Worker handles `/` and returns HTML, this Astro page might not be necessary. The Worker's response will be served directly.

---

## Local Development vs Production Comparison

### Port Exposure

| Aspect | Local Development | Production |
|--------|------------------|------------|
| **Dockerfile Requirement** | `EXPOSE 3001` mandatory | Not required |
| **URL Format** | `http://localhost:8787/...` | `https://3001-{id}-express.domain.com` |
| **Domain Setup** | None needed | Custom domain + wildcard DNS |
| **SSL** | None | Automatic with custom domain |
| **Preview URL** | Accessible via Worker proxy | Direct subdomain access |

### Key Differences

1. **Initialization**: Auto-starts on first request in both environments
2. **Iframe src**: Local uses relative/proxied URL, Production uses absolute preview URL
3. **Sandbox ID**: `normalizeId: true` ensures lowercase for compatibility
4. **Container startup**: Local is instant (local Docker), Production takes 2-3 minutes (first deploy)

---

## Testing Strategy

### Local Development

```bash
# 1. Install dependencies
npm install

# 2. Generate types
npm run types

# 3. Start dev server
npm run dev

# 4. Open browser
# Navigate to http://localhost:4321 (Astro)
# The Worker auto-initializes and shows iframe with Express output

# 5. Check console for preview URL
# Look for: "Preview URL: http://localhost:8787/..."
```

### Production Deployment

```bash
# 1. Build and deploy
npm run deploy

# 2. Wait 2-3 minutes for container provisioning

# 3. Access via custom domain
# https://your-domain.com/
# Should show iframe with https://3001-{id}-express.your-domain.com/
```

---

## Common Issues

### "Connection refused: container port not found"
**Solution**: Add `EXPOSE 3001` to Dockerfile.

### Port 3000 errors
**Solution**: Use port 3001 (3000 is reserved by Sandbox internal Bun server).

### Preview URL not accessible
**Solution**: Ensure `normalizeId: true` is set in `getSandbox()`.

### Types not found
**Solution**: Run `npm run types` to generate `workers-configuration.d.ts`.

---

## Deployment Checklist

- [ ] SDK version matches Docker image (0.7.4)
- [ ] `EXPOSE 3001` in Dockerfile
- [ ] `normalizeId: true` in Worker
- [ ] `wrangler types` generated
- [ ] Custom domain configured (production)
- [ ] Wildcard DNS record added (production)

---

## File Summary

| File | Purpose | Lines |
|------|---------|-------|
| `package.json` | Project dependencies | 25 |
| `tsconfig.json` | TypeScript config | 15 |
| `wrangler.jsonc` | Wrangler configuration | 25 |
| `astro.config.mjs` | Astro + Cloudflare adapter | 20 |
| `sandbox/Dockerfile` | Container definition | 20 |
| `sandbox/express-app/package.json` | Express deps | 10 |
| `sandbox/express-app/server.js` | Express server | 25 |
| `src/worker/index.ts` | Worker entry (auto-start) | 120 |
| `src/pages/index.astro` | Astro page | 20 |

**Total:** 9 files, ~280 lines of code (significantly reduced from original 12 files / 450 lines)

---

## Key Revisions Summary

1. **Unified Structure**: Single Astro project with Cloudflare adapter instead of separate worker + frontend
2. **Auto-Start**: Sandbox initializes automatically on first request, no REST API needed
3. **Type Generation**: Use `wrangler types` instead of manual workers-types package
4. **Simplified Frontend**: Just an iframe showing the sandbox preview
5. **Hono.js**: Minimal routing for proxyToSandbox middleware
6. **Logging**: Preview URL logged to console for visibility
