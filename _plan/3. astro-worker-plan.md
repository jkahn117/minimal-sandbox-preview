# Astro + Worker Architecture Plan (RPC + WebSocket Hybrid)

## Overview

Use Astro Actions with RPC to call the Worker from the frontend, and WebSocket to receive real-time progress updates from the sandbox during initialization. This combines type-safe RPC calls with real-time status updates.

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Astro Frontend                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  src/pages/index.astro                                  │   │
│  │  - Server-rendered page                                 │   │
│  │  - Uses SandboxComponent                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  src/components/SandboxComponent.astro                  │   │
│  │  - Calls Astro actions (RPC) to start sandbox           │   │
│  │  - WebSocket connection for progress updates            │   │
│  │  - Reactive UI with state management                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  src/actions/index.ts                                   │   │
│  │  - Astro actions definition                             │   │
│  │  - RPC calls to Worker service binding                  │   │
│  │  - startSandbox() -> returns { wsEndpoint: '...' }      │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ↕ RPC (Service Binding)
┌─────────────────────────────────────────────────────────────────┐
│                    Cloudflare Worker (API)                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  src/worker/index.ts                                    │   │
│  │  - Hono router with RPC methods                         │   │
│  │  - /api/start (RPC) -> starts sandbox + returns WS URL  │   │
│  │  - /ws (WebSocket) -> streams progress updates          │   │
│  │  - /api/preview/* -> proxy to sandbox                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                      ↓                                          │
│         Durable Object (stateful coordination)                  │
│         - WebSocket connections stored here                     │
│         - Broadcasts updates during initialization              │
│                      ↓                                          │
│            Container Instance (isolated)                        │
│         - Initialization steps broadcast via WebSocket          │
└─────────────────────────────────────────────────────────────────┘
```

## Data Flow

1. **Page Load** → Astro component renders
2. **Call RPC** → `actions.startSandbox()` via service binding
3. **Worker Response** → Returns `{ wsEndpoint: '/ws', sandboxId: '...' }`
4. **WebSocket Connect** → Client connects to WebSocket endpoint
5. **Real-time Updates** → Worker broadcasts progress during initialization
6. **Ready State** → WebSocket sends `{ type: 'ready', previewUrl: '...' }`
7. **Show Iframe** → Component renders preview URL

## Key Features

1. **Type-Safe RPC**: Astro actions provide type-safe calls to Worker
2. **Service Binding**: Worker exposed as `MY_WORKER` service
3. **WebSocket Updates**: Real-time progress during sandbox initialization
4. **Separation of Concerns**: RPC for commands, WebSocket for events
5. **Astro Components**: Reactive UI using Astro patterns

## File Structure

```
sandbox-minimal-example/
├── package.json                    # Dependencies
├── wrangler.jsonc                  # Worker + service binding config
├── astro.config.mjs                # Astro + Cloudflare adapter
├── tsconfig.json                   # TypeScript config
├── sandbox/                        # Container config
│   ├── Dockerfile
│   └── express-app/
│       ├── package.json
│       ├── pnpm-lock.yaml
│       └── server.js
└── src/
    ├── worker/                     # Worker entry point
    │   └── index.ts                # RPC methods + WebSocket
    ├── actions/                    # Astro actions
    │   └── index.ts                # RPC action definitions
    ├── components/                 # Astro components
    │   └── SandboxComponent.astro  # Reactive UI component
    └── pages/
        └── index.astro             # Main page
```

## Implementation Details

### 1. Worker (src/worker/index.ts)

```typescript
import { getSandbox, proxyToSandbox, type Sandbox } from '@cloudflare/sandbox';
import { Hono } from 'hono';

export { Sandbox } from '@cloudflare/sandbox';

type Env = {
  Sandbox: DurableObjectNamespace<Sandbox>;
};

// Store WebSocket connections in Durable Object
class SandboxManager {
  private connections = new Set<WebSocket>();
  private sandbox: Sandbox;
  private isReady = false;
  private previewUrl: string | null = null;

  constructor(state: DurableObjectState, env: Env) {
    this.sandbox = getSandbox(env.Sandbox, 'minimal-example-sandbox', {
      normalizeId: true
    });
  }

  // RPC method called via service binding
  async start(host: string) {
    if (this.isReady) {
      return { 
        status: 'ready', 
        previewUrl: this.previewUrl,
        wsEndpoint: '/ws'
      };
    }

    // Start initialization (async, don't await)
    this.initialize(host);

    return {
      status: 'initializing',
      wsEndpoint: '/ws',
      message: 'Connect to WebSocket for progress updates'
    };
  }

  // WebSocket handler
  async handleWebSocket(ws: WebSocket) {
    this.connections.add(ws);
    
    ws.accept();
    ws.send(JSON.stringify({ type: 'connected' }));

    // If already ready, send immediately
    if (this.isReady) {
      ws.send(JSON.stringify({
        type: 'ready',
        previewUrl: this.previewUrl
      }));
    }

    ws.addEventListener('close', () => {
      this.connections.delete(ws);
    });
  }

  private async initialize(host: string) {
    try {
      this.broadcast({ type: 'progress', step: 'creating_workspace' });
      await this.sandbox.mkdir('/workspace', { recursive: true });

      this.broadcast({ type: 'progress', step: 'writing_files' });
      await this.setupFiles();

      this.broadcast({ type: 'progress', step: 'installing_dependencies' });
      await this.sandbox.exec('npm install', { cwd: '/workspace' });

      this.broadcast({ type: 'progress', step: 'starting_server' });
      await this.sandbox.startProcess('node server.js', {
        cwd: '/workspace',
        env: { PORT: '3001', NODE_ENV: 'production' }
      });

      this.broadcast({ type: 'progress', step: 'waiting_for_ready' });
      await this.waitForReady();

      this.broadcast({ type: 'progress', step: 'exposing_port' });
      const exposed = await this.sandbox.exposePort(3001, {
        hostname: host,
        name: 'express-server',
        token: 'express'
      });

      this.previewUrl = exposed.url;
      this.isReady = true;

      this.broadcast({
        type: 'ready',
        previewUrl: this.previewUrl
      });
    } catch (error) {
      this.broadcast({
        type: 'error',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  private broadcast(message: any) {
    const data = JSON.stringify(message);
    this.connections.forEach(ws => {
      if (ws.readyState === WebSocket.READY_STATE_OPEN) {
        ws.send(data);
      }
    });
  }

  // ... helper methods ...
}

const app = new Hono<{ Bindings: Env }>();

// RPC endpoint for Astro actions
app.post('/api/start', async (c) => {
  const { host } = await c.req.json();
  const id = c.env.Sandbox.idFromName('minimal-example-sandbox');
  const manager = c.env.Sandbox.get(id);
  
  const result = await manager.start(host);
  return c.json(result);
});

// WebSocket endpoint for real-time updates
app.get('/ws', async (c) => {
  const upgradeHeader = c.req.header('Upgrade');
  if (upgradeHeader !== 'websocket') {
    return c.text('Expected websocket', 400);
  }

  const [client, server] = Object.values(new WebSocketPair());
  
  const id = c.env.Sandbox.idFromName('minimal-example-sandbox');
  const manager = c.env.Sandbox.get(id);
  
  await manager.handleWebSocket(server);
  
  return new Response(null, {
    status: 101,
    webSocket: client
  });
});

export default app;
```

### 2. Astro Actions (src/actions/index.ts)

```typescript
import { defineAction } from 'astro:actions';
import { z } from 'zod';

export const server = {
  startSandbox: defineAction({
    input: z.object({
      host: z.string()
    }),
    handler: async (input, context) => {
      const worker = context.locals.runtime.env.MY_WORKER;
      return await worker.start(input.host);
    }
  })
};
```

### 3. Reactive Component (src/components/SandboxComponent.astro)

```astro
---
interface Props {
  host: string;
}

const { host } = Astro.props;
---

<div class="sandbox-container" data-host={host}>
  <div class="loading-state" style="display: block;">
    <div class="spinner"></div>
    <div class="status-text">Starting...</div>
    <div class="step-indicator"></div>
  </div>

  <div class="ready-state" style="display: none;">
    <div class="preview-url"></div>
    <iframe src="" title="Sandbox Preview" loading="lazy"></iframe>
  </div>

  <div class="error-state" style="display: none;">
    <div class="error-message"></div>
    <button class="retry-btn">Retry</button>
  </div>
</div>

<script>
  import { actions } from 'astro:actions';

  const container = document.querySelector('.sandbox-container');
  const host = container?.dataset.host;

  // Initialize: Call RPC to start sandbox, then connect WebSocket
  async function init() {
    try {
      // Step 1: Call RPC to trigger initialization
      const result = await actions.startSandbox({ host: host! });
      
      if (result.data?.status === 'ready') {
        showReady(result.data.previewUrl);
        return;
      }

      // Step 2: Connect to WebSocket for progress updates
      const wsEndpoint = result.data?.wsEndpoint || '/ws';
      connectWebSocket(wsEndpoint);
      
    } catch (err) {
      showError('Failed to start sandbox');
    }
  }

  function connectWebSocket(endpoint: string) {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${protocol}//${window.location.host}${endpoint}`);

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleMessage(data);
    };

    ws.onerror = () => {
      showError('WebSocket connection failed');
    };

    ws.onclose = () => {
      // Auto-reconnect if not ready
      const ready = container?.querySelector('.ready-state')?.style.display === 'block';
      if (!ready) {
        setTimeout(() => connectWebSocket(endpoint), 3000);
      }
    };
  }

  function handleMessage(data: any) {
    switch (data.type) {
      case 'progress':
        updateStep(data.step);
        break;
      case 'ready':
        showReady(data.previewUrl);
        break;
      case 'error':
        showError(data.message);
        break;
    }
  }

  function updateStep(step: string) {
    const statusEl = container?.querySelector('.status-text');
    const stepEl = container?.querySelector('.step-indicator');
    
    if (statusEl) statusEl.textContent = getStepDescription(step);
    if (stepEl) stepEl.textContent = step;
  }

  function showReady(url: string) {
    const loadingEl = container?.querySelector('.loading-state');
    const readyEl = container?.querySelector('.ready-state');
    const urlEl = container?.querySelector('.preview-url');
    const iframeEl = container?.querySelector('iframe');

    if (loadingEl) loadingEl.style.display = 'none';
    if (readyEl) readyEl.style.display = 'block';
    if (urlEl) urlEl.textContent = url;
    if (iframeEl) iframeEl.src = url;
  }

  function showError(message: string) {
    const loadingEl = container?.querySelector('.loading-state');
    const errorEl = container?.querySelector('.error-state');
    const errorMsgEl = container?.querySelector('.error-message');

    if (loadingEl) loadingEl.style.display = 'none';
    if (errorEl) errorEl.style.display = 'block';
    if (errorMsgEl) errorMsgEl.textContent = message;
  }

  function getStepDescription(step: string) {
    const steps: Record<string, string> = {
      'creating_workspace': 'Creating workspace...',
      'writing_files': 'Setting up Express server...',
      'installing_dependencies': 'Installing dependencies...',
      'starting_server': 'Starting Express server...',
      'waiting_for_ready': 'Waiting for server to be ready...',
      'exposing_port': 'Configuring preview URL...',
    };
    return steps[step] || 'Initializing...';
  }

  // Retry button
  container?.querySelector('.retry-btn')?.addEventListener('click', () => {
    location.reload();
  });

  // Auto-start
  init();
</script>

<style>
  .sandbox-container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .loading-state {
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 40px;
    text-align: center;
    height: 400px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #e3f2fd;
    border-top: 4px solid #2196f3;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .step-indicator {
    color: #666;
    font-size: 14px;
    margin-top: 10px;
  }

  iframe {
    width: 100%;
    height: 600px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
  }

  .error-state {
    text-align: center;
    padding: 40px;
  }
</style>
```

### 4. Configuration (wrangler.jsonc)

```jsonc
{
  "$schema": "./node_modules/wrangler/config-schema.json",
  "name": "sandbox-minimal-example",
  "main": "./src/worker/index.ts",
  "compatibility_date": "2026-02-18",
  "compatibility_flags": ["nodejs_compat"],
  
  "containers": [
    {
      "name": "Sandbox",
      "class_name": "Sandbox",
      "image": "./sandbox/Dockerfile",
      "instance_type": "lite",
      "max_instances": 1
    }
  ],
  
  "durable_objects": {
    "bindings": [
      {
        "class_name": "Sandbox",
        "name": "Sandbox"
      }
    ]
  },
  
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["Sandbox"]
    }
  ],

  // Service binding for RPC
  "services": [
    {
      "binding": "MY_WORKER",
      "service": "sandbox-minimal-example"
    }
  ],
  
  "env": {
    "production": {
      "name": "sandbox-minimal-example",
      "routes": [
        {
          "pattern": "sandbox.cfsa.dev",
          "custom_domain": true
        },
        {
          "pattern": "*.sandbox.cfsa.dev",
          "zone_name": "cfsa.dev"
        }
      ],
      "workers_dev": false,
      "services": [
        {
          "binding": "MY_WORKER",
          "service": "sandbox-minimal-example"
        }
      ]
    }
  }
}
```

## Data Flow Summary

1. **Astro Component** calls `actions.startSandbox()` (RPC via service binding)
2. **Worker** receives RPC call, starts initialization, returns WebSocket endpoint
3. **Component** connects to WebSocket at returned endpoint
4. **Worker** broadcasts progress updates during initialization
5. **Component** receives updates and updates UI
6. **Worker** sends `ready` message with preview URL
7. **Component** shows iframe with preview

## Benefits

1. **Type-Safe**: Astro actions provide type safety for RPC
2. **Real-Time**: WebSocket provides instant progress updates
3. **Clean API**: RPC for commands, WebSocket for events
4. **Scalable**: Service binding allows Worker to call itself
5. **Standard Patterns**: Uses Astro's recommended action patterns
